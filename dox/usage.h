/**
 * @page dub_usage Dub Usage
 *
 * @subsection dub_method_overrides Method Overrides
 *
 * @subsubsection dub_gc Mark this function as factory method.
 *
 * \@dub gc: true
 *
 * Set this value in a method to mark it as a factory method: In other words,
 * it's creating a new object that should be managed by Lua. Only makes sense on
 * functions that return a pointer generated by new.
 *
 * @subsection dub_class_overrides Class Overrides
 *
 * @subsubsection dub_push Mark a function as a "push" function
 *
 * @paragraph dub_push_1
 *
 * \@dub push: "functionName" -- typically "push"
 *
 * Set the name of the function to push this class onto the Lua stack. The
 * signature of the function should match:
 *
 * @code
 * void pushobject(lua_State* L, void* thisPtr,
 * 					const char * className, bool shouldGC);
 * @endcode
 *
 * Instead of "void *", the <b>thisPtr</b> can be defined as a pointer to the
 * current class. In most cases the pointer here will be the same as
 * <b>this</b>.
 *
 * The <b>className</b> will be passed in as the string that Dub uses
 * to identify the class in question.
 *
 * The boolean shouldGC will be true if Dub believes Lua should garbage-collect
 * the value. In practice this means that the call is being made in the
 * constructor of the class, or a method
 *
 * @subsubsection dub_destroy_free POD Class Optimization/Destructor Disabling
 *
 * @paragraph dub_destroy_free_1 Dub Command
 * \@dub destroy: 'free'
 *
 * @paragraph dub_destroy_free_1 Inspector Command
 * @code
 * local a = inspector.find("classname");
 * a.dub = { destroy = "free" }
 * @endcode
 *
 * This enables objects to be created with in-place new, preventing an
 * allocation and a copy, and it also completely disables the __gc garbage
 * collection callback for the class.
 *
 * Ideal for POD types that support operators. A vector class Vec2 that supports
 * operator+, for example, would be able to create a single extra Lua USERDATA
 * with an embedded Vec2 result constructed right in the USERDATA.
 *
 * @subsubsection dub_class_init Post-Creation Init
 *
 * @paragraph dub_class_init_1 Dub Command
 * @code
 * \@dub init: 'luaInit'
 * @endcode
 *
 * @paragraph dub_class_init_2 Inspector Command
 * @code
 * local a = inspector.find("classname");
 * a.dub = { init = "luaInit" }
 * @endcode
 *
 * @paragraph dub_class_init_3 Inspector Command
 * Causes Dub to call luaInit function after creating an instance of classname.
 * The luaInit function has the form:
 *
 * @code
 * int luaInit( lua_State * L );
 * @endcode
 *
 * This function can be used to do extra post-construction initialization for a
 * class.
 */
