#include "<%= @class.header %>"

#include "lua_cpp_helper.h"

<%# We need this to serialize superclass members properly %>
<% Lua.function_generator.klass = @class %>

<% if @class.prefix %>
using namespace <%= @class.prefix %>;
<% end %>

/* ============================ Constructors     ====================== */

<%= @class.constructor %>

<% if @class.opts[:destructor] == '' %>
// Destructor disabled for this class
<% else %>
/* ============================ Destructor       ====================== */

static int <%= @class.destructor_name %>(lua_State *L) {
  <%= @class.name %> **userdata = (<%= @class.name %>**)dubL_checksdata_n(L, 1, <%= @class.id_name.inspect %>);

  <% if @class.custom_destructor? %>
  // custom destructor
  if (*userdata) (*userdata)-><%= @class.opts[:destructor] %>();
  <% else %>
  if (*userdata) delete *userdata;
  <% end %>
  *userdata = NULL;
  return 0;
}
<% end %>

<% if @class.custom_destructor? %>

// test if class is deleted
static int <%= @class.is_deleted_name %>(lua_State *L) {
  <%= @class.name %> **userdata = (<%= @class.name %>**)dubL_checksdata_n(L, 1, <%= @class.id_name.inspect %>);
  lua_pushboolean(L, *userdata == NULL);
  return 1;
}
<% end %>
/* ============================ tostring         ====================== */

static int <%= @class.tostring_name %>(lua_State *L) {
  <%= @class.name %> **userdata = (<%= @class.name %>**)dubL_checksdata_n(L, 1, <%= @class.id_name.inspect %>);
  <% if @class.custom_destructor? %>
  if (!*userdata) {
    lua_pushstring(L, "<<%= @class.id_name %>: NULL>");
    return 1;
  }
  <% end %>
  <% if @class.opts[:string_format] %>
  lua_pushfstring(L, "<<%= @class.id_name %>: %p <%= @class.string_format %>>", *userdata, <%= @class.string_args %>);
  <% else %>
  lua_pushfstring(L, "<<%= @class.id_name %>: %p>", *userdata);
  <% end %>
  return 1;
}

/* ============================ Member Methods   ====================== */

<% if @class.members; @class.members.each do |function| %>
<%= function %>

<% end; end %>


/* ============================ Lua Registration ====================== */

static const struct luaL_Reg <%= @class.name %>_member_methods[] = {
<%= indent(method_registration, 2) %>,
  {NULL, NULL},
};

static const struct luaL_Reg <%= @class.name %>_namespace_methods[] = {
<%= indent(namespace_methods_registration, 2) %>,
  {NULL, NULL},
};

<% if @class.has_constants? %>
static const struct lua_constants_Reg <%= @class.name %>_namespace_constants[] = {
<%= indent(constants_registration, 2) %>,
  {NULL, NULL},
};
<% end %>

#ifdef DUB_LUA_NO_OPEN
int luaload_<%= @class.prefix %>_<%= @class.lib_name %>(lua_State *L) {
#else
extern "C" int luaopen_<%= @class.prefix %>_<%= @class.lib_name %>(lua_State *L) {
#endif
  // Create the metatable which will contain all the member methods
  luaL_newmetatable(L, <%= @class.id_name.inspect %>);

  // metatable.__index = metatable (find methods in the table itself)
  lua_pushvalue(L, -1);
  lua_setfield(L, -2, "__index");

  // register member methods
  luaL_register(L, NULL, <%= @class.name %>_member_methods);
  // save meta-table in <%= @class.prefix %>.<%= @class.name %>_
  register_mt(L, <%= @class.prefix.inspect %>, <%= @class.name.inspect %>);

  // register class methods in a global namespace table
  luaL_register(L, <%= @class.prefix.inspect %>, <%= @class.name %>_namespace_methods);

<% if @class.has_constants? %>
  // register class enums
  register_constants(L, <%= (@class.id_name + '_const').inspect %>, <%= @class.name %>_namespace_constants);
<% end %>
	return 1;
}
